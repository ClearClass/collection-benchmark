## О проекте

Целью исследования является экспериментальная оценка времени выполнения основных операций (чтение, поиск, вставка, удаление) для различных видов коллекций, в функции текущего размера коллекции. В качестве коллекций были рассмотрены списки (`List`), представленные классами `ArrayList` и `LinkedList`, и множества, в виде классов `HashSet` и `TreeSet`. Для одних оценок выполнялось усреднение по ансамблю, другие оценки представлены в исходном виде. Во всех случаях в качестве типа данных коллекции использовался тип `Integer`.

Для построения графиков может использоваться либо Matlab (в состав которого, начиная с версии R2016b, входит встроенное API для взаимодействия с Java-приложениями), либо свободная утилита gnuplot, предоставляющая стандартный поток для ввода данных и команд из внешнего приложения (начиная с версии 5.0.1). В настоящем проекте реализованы оба этих подхода; для построения графиков, приведенных ниже, использовался способ на основе gnuplot.

### Основные результаты

На **рисунке 1** представлены результаты чтения центрального элемента списка.

![img1](../resources/images/img1.png "Рисунок 1 - Чтение центрального элемента списка")

Из приведенных графиков видно, что полученные оценки полностью соответствуют теоретическим представлениям, т.е. для связанного списка сложность чтения центрального элемента является линейной, а для динамического массива - константной.

На **рисунке 2** показаны результаты для операции вставки в середину списка.

![img2](../resources/images/img2.png "Рисунок 2 - Вставка в середину списка")

В обоих случаях сложность является линейной, однако для динамического массива эта операция выполняется быстрее, чем для связанного списка, несмотря на то, что в массиве приходится сдвигать половину элементов, чтобы освободить центральную ячейку.

**Рисунок 3** - вставка в начало списка для `LinkedList` выполняется более эффективно, чем для `ArrayList`.

![img3](../resources/images/img3.png "Рисунок 3 - Вставка в начало списка")
 
На **рисунке 4** показаны результаты поиска элемента в неотсортированном списке с использованием методов `indexOf()` и `contains()` (оба метода дают идентичные результаты). 

![img4](../resources/images/img4.png "Рисунок 4 - Поиск в неотсортированном списке")

Условия эксперимента были поставлены так, что в большинстве случаев искомый элемент отсутствовал в списке, однако в некоторых случаях он находился в начале списка, за счет чего время поиска в этих точках было существенно меньше среднего (что проявляется на графиках в виде отдельных отрицательных пиков).

Полученные данные демонстрируют неожиданный результат - линейный поиск в связанном списке происходит несколько быстрее, чем в динамическом массиве. Для объяснения полученных данных был проведен прямой эксперимент, имитирующий процедуру линейного поиска - перебор всех элементов списка с помощью итератора (**рисунок 5**) :

![img5](../resources/images/img5.png "Рисунок 5 - Чтение всех элементов списка с помощью итератора")

Однако здесь результаты получаются полностью противоположными.

### Множества

Во второй серии экспериментов проводился анализ выполнения базовых операций (вставка, поиск, удаление) для двух реализаций множества - `HashSet` и `TreeSet`. Во всех случаях полученные оценки полностью соответствовали теоретическим: `O(1)` для `HashSet` и `O(log(n))` для `TreeSet`. На **рисунке 6** в качестве примера показаны результаты операции поиска, усредненные по тысяче реализаций.

![img6](../resources/images/img6.png "Рисунок 6 - Поиск в множестве")

По результатам эксперимента, время поиска в хеш-таблице примерно в 40 раз меньше, чем время вставки/удаления в ней.